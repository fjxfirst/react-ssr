一、使用nodemon监听js文件的变化，实现服务自动重启
npm install nodemon -g
在package.json中配置命令"start":"nodemon --watch build --exec node \"./build/bundle.js\"",
表示监听build目录中的文件，如果build中的文件有变化则重新执行bundle.js,因为外层已经包裹了一次",所以\"表示转义
使用webpack的--watch参数，"build": "webpack --config webpack.server.js --watch"
这样先执行npm run build,再执行npm start就实现了服务自动重启
二、npm-run-all提示开发效率
npm install npm-run-all
"dev":"npm-run-all --parallel dev:**", 表示并行执行以dev开头的命令，
"dev:start":"nodemon --watch build --exec node \"./build/bundle.js\"",
"dev:build": "webpack --config webpack.server.js --watch"
这样在开发时只需要执行npm run dev即可
三、在服务器端要使用React.hydrate，而不能使用render
四、服务端渲染要使用react-router-dom中的StaticRouter
<StaticRouter location={req.path} context={{}}>
        {Routes}
      </StaticRouter>
StaticRouter无法感知到地址路径的变化，所以需要location参数，context是通信数据的获取，用来做数据的传递
五、使用redux
六、react生命周期函数不会在服务端执行,需要使用matchPath，
const matchRoutes=[]
  routes.some(route => { //遍历routes中的每一条路由
    //如果当前请求的路径和route中的路由能匹配上，match就为true
    const match = matchPath(req.path, route);
    if (match){
      matchRoutes.push(route)
    }
  });
这里可能会出现多余的一个空数组，原因是请求favicon.ico造成的，解决办法是把favicon.ico文件放入public目录下
七、多层路由问题
  {
    path:'/',
    component:Home,
    exact:true,
    //当加载Home组件之前会执行loadData方法
    loadData:Home.loadData,
    key:'home',
    routes:[
      {
        path:'/ttt',
        component:Login,
        exact:true,
        key:'ttt'
      }
    ]
  }
  当访问/ttt时，matchPath匹配不到/ttt，这里就要用到react-router-config
  安装react-router-config，npm install react-router-config --save
  使用react-router-config中的matchRoutes,就可以匹配多级路由
八、首次渲染页面抖动问题，原因是服务端的store和浏览器端的store不一致，当服务端的store有数据后，浏览器端的js重新渲染时，它的store是空的，
所以页面内容就会白屏闪一下。解决方法：
数据的注水与脱水，这样首次渲染时store就一致了
注水：将服务器端的state放到window.context中
<html>
      <head>
        <title>ssr</title>
      </head>
      <body>
        <div id="root">${content}</div>
        <script>
        window.context={
          state: ${JSON.stringify(store.getState())}
        }
        </script>
        <script src="/index.js"></script>
      </body>
</html>
脱水：客户端使用的store初始数据之接从window.context中获取
export const getClientStore=()=>{
  //保证服务端的初始数据和浏览器端的初始数据一致，作为reducer的初始默认数据
  const defaultState = window.context.state //数据的脱水
  return createStore(reducer,defaultState,applyMiddleware(thunk))
}
首页组件的componentDidMount可以做优化处理，如果有数据了就不用发送请求
componentDidMount() {
    if(!this.props.list){
      this.props.getHomeList()
    }
}
九、node作为数据获取中间层
axios.get('/api/v2/movie/in_theaters?city=%E5%B9%BF%E5%B7%9E&start=0&count=10')
安装express-http-proxy
import proxy from 'express-http-proxy'
app.use('/api',proxy('https://api.douban.com', {
  proxyReqPathResolver: function (req) {
    console.log(req.url)
    return '/v2/movie/in_theaters?city=%E5%B9%BF%E5%B7%9E&start=0&count=10'
  }
}))
第一个参数'/api',表示接口地址匹配成功的话,会被转发到'https://api.douban.com/v2/movie/in_theaters?city=%E5%B9%BF%E5%B7%9E&start=0&count=10'
十、服务器端请求和客户端请求的不同处理
浏览器运行这段代码:
/api/v2/movie/in_theaters?city=%E5%B9%BF%E5%B7%9E&start=0&count=10等价于请求http://localhost:3000/api/v2/movie/in_theaters?city=%E5%B9%BF%E5%B7%9E&start=0&count=10
如果是服务器运行:
/api/v2/movie/in_theaters?city=%E5%B9%BF%E5%B7%9E&start=0&count=10等价于服务器根目录下/api/v2/movie/in_theaters?city=%E5%B9%BF%E5%B7%9E&start=0&count=10
解决办法：传入参数server来判断，store.dispatch(getHomeList(true))
  let url=''
  if(server){//如果是服务端渲染
    url='https://api.douban.com/v2/movie/in_theaters?city=%E5%B9%BF%E5%B7%9E&start=0&count=10'
  }else{
    url='/api/v2/movie/in_theaters?city=%E5%B9%BF%E5%B7%9E&start=0&count=10'
  }
axios.get(url)
十一、axios中instance的使用
import axios from 'axios'
const instance =axios.create({
  baseURL:'https://api.douban.com' //对于服务器端
})
export default instance
十二、巧用redux-thunk中的withExtraArgument
使用thunk.withExtraArgument直接将对应的axiosInstance带入action中
export const getClientStore=()=>{
  //保证服务端的初始数据和浏览器端的初始数据一致，作为reducer的初始默认数据
  const defaultState = window.context.state //数据的脱水
  //改变服务器端store的内容，那么就一定要使用clientAxios
  return createStore(reducer,defaultState,applyMiddleware(thunk.withExtraArgument(clientAxios)))
}
这样就不需要store.dispatch(getHomeList(true))传入的布尔类型的判断参数了
十三、使用renderRoutes方法实现对多级路由的支持
当用户访问'/'路径时，能匹配出App和Home组件
当用户访问'/login'路径时，能匹配出App和Login组件
  {
    path:'/',
    component:App,
    routes:[
      {
        path:'/',
        component:Home,
        exact:true,
        //当加载Home组件之前会执行loadData方法
        loadData:Home.loadData,
        key:'home'
      },
      {
        path:'/login',
        component:Login,
        exact:true,
        key:'login'
      }
    ]
  }
但是多级路由就不能使用
{routes.map(route => (
 <Route {...route} />
))}了，这里就要使用import {renderRoutes} from "react-router-config",{renderRoutes(routes)},但此时只会展示第一层路由
还需要在App组件中使用
            import {renderRoutes} from "react-router-config"
            const App=()=>{
              return (
                <div>
                  <Header/>
                  {renderRoutes(props.route.routes)}
                </div>
              )
            }
再把Home和Login中的Header组件删除,同时client的路由也要使用{renderRoutes(props.route.routes)}