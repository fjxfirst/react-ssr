一、使用nodemon监听js文件的变化，实现服务自动重启
npm install nodemon -g
在package.json中配置命令"start":"nodemon --watch build --exec node \"./build/bundle.js\"",
表示监听build目录中的文件，如果build中的文件有变化则重新执行bundle.js,因为外层已经包裹了一次",所以\"表示转义
使用webpack的--watch参数，"build": "webpack --config webpack.server.js --watch"
这样先执行npm run build,再执行npm start就实现了服务自动重启
二、npm-run-all提示开发效率
npm install npm-run-all
"dev":"npm-run-all --parallel dev:**", 表示并行执行以dev开头的命令，
"dev:start":"nodemon --watch build --exec node \"./build/bundle.js\"",
"dev:build": "webpack --config webpack.server.js --watch"
这样在开发时只需要执行npm run dev即可
三、在服务器端要使用React.hydrate，而不能使用render
四、服务端渲染要使用react-router-dom中的StaticRouter
<StaticRouter location={req.path} context={{}}>
        {Routes}
      </StaticRouter>
StaticRouter无法感知到地址路径的变化，所以需要location参数，context是通信数据的获取，用来做数据的传递
五、使用redux
六、react生命周期函数不会在服务端执行,需要使用matchPath，
const matchRoutes=[]
  routes.some(route => { //遍历routes中的每一条路由
    //如果当前请求的路径和route中的路由能匹配上，match就为true
    const match = matchPath(req.path, route);
    if (match){
      matchRoutes.push(route)
    }
  });
这里可能会出现多余的一个空数组，原因是请求favicon.ico造成的，解决办法是把favicon.ico文件放入public目录下
七、多层路由问题
  {
    path:'/',
    component:Home,
    exact:true,
    //当加载Home组件之前会执行loadData方法
    loadData:Home.loadData,
    key:'home',
    routes:[
      {
        path:'/ttt',
        component:Login,
        exact:true,
        key:'ttt'
      }
    ]
  }
  当访问/ttt时，matchPath匹配不到/ttt，这里就要用到react-router-config
  安装react-router-config，npm install react-router-config --save
  使用react-router-config中的matchRoutes,就可以匹配多级路由